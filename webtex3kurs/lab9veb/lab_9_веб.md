## Міністерство освіти і науки України

## Львівський національний університет природокористування

### Факультет механіки, енергетики та інформаційних технологій

#### Кафедра інформаційних технологій

------------------------------------------------------------------------

# **Звіт**

про виконання лабораторної роботи №9\
з дисципліни **«Веб технології та веб дизайн»**\
на тему:\
**Аутентифікація та сесії. Логін/реєстрація з збереженням користувачів у JSON**

**Виконав:** студент групи **КН-31**, Вирста Андрій\
**Прийняв:** викл. **Тарас Квасниця**

**Львів --- 2025**

------------------------------------------------------------------------

## **Мета роботи**

- Ознайомитися з базовими принципами аутентифікації та управління сесіями у веб-застосунках.
- Навчитися реалізовувати реєстрацію та логін користувачів без зовнішніх СУБД.
- Опанувати middleware для захисту маршрутів (авторизований доступ).
- Закріпити використання express-validator, express-session, bcrypt та JSON-файлу як сховища користувачів.

------------------------------------------------------------------------

## **Теоретичні відомості**

### **Аутентифікація та авторизація**

| Термін | Пояснення | Приклад |
|--------|-----------|---------|
| Аутентифікація (Authentication) | Перевірка особи користувача («Хто ти?») | Введення email + пароль |
| Авторизація (Authorization) | Визначення прав доступу («Що ти можеш робити?») | Лише авторизовані можуть видаляти завдання |
| Сесія (Session) | Тимчасовий стан користувача між HTTP-запитами | req.session.user = {id: 1} |
| Куки (Cookies) | Невеликі дані у браузері, що надсилаються з кожним запитом | connect.sid=s%3A... |

### **express-session**

- Використовується для збереження стану користувача між запитами.
- Створює session ID, який зберігається у cookie браузера.
- Десеріалізує ID та підставляє у `req.session`.

### **bcrypt**

- Хешує паролі для безпечного зберігання.
- Додає соль автоматично, захищаючи від rainbow tables.
- При логіні використовує `bcrypt.compare` для перевірки пароля.

### **Middleware для аутентифікації**

- `requireAuth` — дозволяє доступ тільки авторизованим.
- `redirectIfAuth` — редіректить авторизованих зі сторінок /login та /register.

### **Валідація (express-validator)**

- Перевірка email, ПІБ, пароля та підтвердження пароля.
- Flash-повідомлення показує помилки користувачу.

### **Структура проєкту**

```
project/
├── users.json
├── public/
├── views/
│   ├── login.ejs
│   ├── register.ejs
│   └── dashboard.ejs
├── middleware/
│   ├── auth.js
│   └── validator.js
├── utils/
│   └── db.js
└── server.js
```

### **Типовий потік користувача**

1. GET /register → форма
2. POST /register → валідація → хеш → збереження → сесія → /dashboard
3. GET /login → форма
4. POST /login → bcrypt.compare → сесія → /dashboard
5. GET /dashboard → requireAuth → показ даних
6. GET /logout → destroy() → /login

------------------------------------------------------------------------

# **Хід роботи**

## **1. Ініціалізація проєкту**

```bash
npm init -y
npm install express express-session bcrypt express-validator ejs connect-flash
```

- Створено файл `users.json` з початковим вмістом `[]`.
- Налаштовано Express, session, flash, парсинг URL-encoded.

## **2. Допоміжні функції для JSON**

```javascript
const fs = require('fs').promises;

async function readUsers() {
  const data = await fs.readFile('users.json', 'utf8');
  return JSON.parse(data);
}

async function writeUsers(users) {
  await fs.writeFile('users.json', JSON.stringify(users, null, 2));
}
```

## **3. Middleware**

- **auth.js**: `requireAuth`, `redirectIfAuth`
- **validator.js**: express-validator правила для реєстрації та логіну

## **4. Маршрути (server.js)**

```javascript
app.get('/register', redirectIfAuth, showRegisterForm);
app.post('/register', registerValidation, handleRegister);

app.get('/login', redirectIfAuth, showLoginForm);
app.post('/login', handleLogin);

app.get('/dashboard', requireAuth, showDashboard);

app.get('/logout', (req, res) => {
  req.session.destroy(() => res.redirect('/login'));
});
```

## **5. Шаблони**

- **register.ejs** — ПІБ, email, пароль, підтвердження
- **login.ejs** — email, пароль
- **dashboard.ejs** — Вітаємо, [ПІБ]! + кнопка Вихід

## **6. Тестування**

✔ Реєстрація нового користувача
✔ Логін з хешованим паролем
✔ Збереження сесії
✔ Перевірка middleware (доступ лише авторизованим)
✔ Flash-повідомлення при помилках

------------------------------------------------------------------------

# **Результати роботи**

- Форма реєстрації/логіну/виходу працює коректно
- Паролі зберігаються у хешованому вигляді
- Сесії зберігаються між запитами
- Захищені маршрути працюють
- ПІБ користувача відображається на дашборді
- Flash-повідомлення показує помилки при некоректних даних

------------------------------------------------------------------------

# **Висновки**

У ході роботи реалізовано систему реєстрації та входу на Node.js + Express.js:  

- Використано **bcrypt** для хешування паролів
- Використано **express-session** для збереження сесій
- Реалізовано **middleware** для захисту маршрутів
- Застосовано **express-validator** для валідації форм
- Дані користувачів зберігаються у JSON-файлі
- Створено інтерфейс з формами та flash-повідомленнями

------------------------------------------------------------------------

# **Контрольні питання та відповіді**

### 1. Різниця між аутентифікацією та авторизацією
- Аутентифікація — перевірка «Хто ти?»  
- Авторизація — перевірка «Що ти можеш робити?»  

### 2. Як express-session зберігає дані між запитами
- Через cookie з session ID; сервер десеріалізує ID у `req.session`.  

### 3. Чому не можна зберігати паролі у відкритому вигляді
- Ризик компрометації та витоку; захист забезпечується хешуванням.  

### 4. Як реалізувати захист маршруту /profile
- Використати middleware `requireAuth`, який перевіряє `req.session.user`.  

### 5. Що таке middleware requireAuth і де його застосовувати
- Функція-перевірка авторизації; застосовується до захищених маршрутів.  

### 6. Як перевірити унікальність email при реєстрації
- Через express-validator, читаючи `users.json` і перевіряючи наявність email.

